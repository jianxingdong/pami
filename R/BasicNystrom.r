library(kernlab)
# Nystrom-based embedding
#X is the original data matrix, cols are data instances and rows are features
#m is the number of samples used for the approximation;   m << number of instances in X
#kernel is the kernel function generated by kernlab's dots
#k is the used rank for the truncated svd;  k<= m

BasicNystrom <- function(X,m, kernel,k){
  n <- dim(X)[2]
  sampleCols <- sample(n,m)
  partialKernel <- matrix(nrow=n,ncol=m)
  allCols <- 1:n 
  remCols <- allCols[!allCols%in%sampleCols]
  r <- n-m
  for(i in 1:m){
   for(j in 1:i){
       partialKernel[i,j] <- partialKernel[j,i] <- kernel(X[,sampleCols[i]], X[,sampleCols[j]])
    }
   
   for(j in 1:r){
       partialKernel[m+j,i] <- kernel(X[,sampleCols[i]], X[,remCols[j]])
   }
  }
  #truncated svd of samples kernel
  s <- svd(partialKernel[1:m,],nu=0, nv=k)
  Y <- t(partialKernel %*% s$v %*% diag(s$d[1:k]^-0.5))
  return(Y)
}

#computes the full kernel matrix
FullKernel <-function(X,kernel){
 n <- dim(X)[2]
 fullKernel <- matrix(nrow=n, ncol=n)
 for(i in 1:n){
   for(j in 1:i){
     fullKernel[i,j] <- fullKernel[j,i] <- kernel(X[,i], X[,j])
   }
 }
 return(fullKernel)
}

#kernel <- polydot(degree = 1, scale = 1, offset = 0)
#kernel <- rbfdot(sigma=0.2)
#Y <- BasicNystrom(t(test$x),100,kernel,40)
#fk <- FullKernel(t(test$x)[,1:100],kernel)
#approxKernel <- crossprod(Y[,1:100])
#norm(approxKernel-fk, type="F")